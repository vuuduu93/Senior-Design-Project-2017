/*
 * File:   Final_Project_1.c
 * Author: nicholasvu
 *
 * Created on April 18, 2016, 5:47 PM
 *
 * 
 * Presented on May 2, 2016 (Early Presentation)
 * 
 * The code in this project represents my own work.
 * It does not include code developed by any other individual or contained in another student?s project.
 */


#include <p33EP128MC502.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <xc.h>
#include <libpic30.h>


#define LCD_data     LATB 
#define LCD_rs      _LATA1
#define LCD_rw      _LATA3
#define LCD_en      _LATA4
#define VREF        3.28 
#define PWM_Period  5000
#define One_A     _LATB10  //Defining 1A and 2A to specific latches
#define Two_A     _LATB11


int i, j;
int u16_adcVal;
float f_adcVal;
float tempc;
float tempf;
int UP = 1;
int FlagCount = 0;

void OSC_Config()
{
    _NOSC = 0b001;
    CLKDIVbits.FRCDIV = 0b000;
    CLKDIVbits.PLLPRE = 0b00001; 
    PLLFBD = 0b001000100;  
    CLKDIVbits.PLLPOST = 0b11; 
    OSCTUN = 4;   
    
    __builtin_write_OSCCONH(0X01);
    __builtin_write_OSCCONL(OSCCON | 0X01);
    
    
    while(OSCCONbits.COSC !=1);
    while (OSCCONbits.LOCK !=1);
}   

void LCD_short_busy() 
{
    for(i = 0; i < 1; i++);    //This portion of the code is very important
    for(j = 0; j < 90; j++);  //If this loop is long, the motor will "hiccup"
}


void LCD_command(unsigned char var)
{
    LCD_data = var;
    LCD_rs   = 0;
    LCD_rw   = 0;
    LCD_en   = 1;  
    LCD_en   = 0;  
    LCD_short_busy();
    
}


void LCD_init()
{
    LCD_command(0x0038); 
    LCD_command(0x000E);
    LCD_command(0x0006);
    LCD_command(0x00C0);
    LCD_command(0x0001);
    
}

void LCD_senddata(unsigned char var) 
{
    LCD_data = var;
    LCD_rs   = 1;
    LCD_rw   = 0;
    LCD_en   = 1;  
    LCD_en   = 0; 
    LCD_short_busy();
}

void LCD_sendstring(char*var) 
{
    while(*var)
        LCD_senddata(*var++);
    
  
}

void config_ADC (void)
{
    AD1CON1 = 0x0000;
    AD1CON2 = 0; 
    AD1CON3 = 0x0001; 
    AD1CSSL = 0;
    
    IFS0bits.AD1IF = 0; 
    AD1CON1bits.ADON = 1;
} 


int run_ADC (int ch) 
{
     AD1CHS0bits.CH0SA = ch;
     AD1CON1bits.SAMP = 1; 
     TMR3 = 0;
     while (TMR3 < 1000);
     AD1CON1bits.SAMP = 0; 
     while (!AD1CON1bits.DONE); 
     AD1CON1bits.DONE = 0; 
     return ADC1BUF0; 
        
} 

void config_IO (void)
{ 
    //Port A configuration for the ADC
    TRISA =  0b00001; 
    ANSELA = 0b00001; 
    LATA =   0b00001;
    PORTA =  0b00001;
    
    //Port B configuration for LCD and H-Bridge IC
    ANSELB = 0;
    TRISB = 0; 
    PORTB = 0;
    LATB = 0xFFFF; 
    
}

void config_T2 (void)
{ 
    T2CON = 0; 
    T2CONbits.TCKPS = 0b11;
    PR2  = 7812;
    TMR2 = 0;
    _T2IP = 2;
    _T2IE = 0; 
    _T2IF = 0;
    T2CONbits.TON = 1; 
  
}
void config_T3 (void)
{ 
    T3CON = 0; 
    T3CONbits.TCKPS = 0b11; 
    PR3 = 62499; 
    TMR3 = 0; 
    T3CONbits.TON = 1; 
    _T3IP = 2;
    _T3IE = 0; 
    _T3IF = 0;
    } 

void Run_T3 (int time) //My own configuration for running timer 3 using a pointer
{  
    int i = time;
    
    for ((i = 0); (i < time); i++)  
    {
    
        T3CONbits.TCKPS  = 0b11;
        PR3     = 62499;
        T3CONbits.TON   = 0;
        TMR3 = 0;
        T3CONbits.TON   = 1;
        while (!_T3IF);
        _T3IF = 0;
    }          
}  



void config_PWM () 
{
    
    OC1CON1 = 0; 
    OC1CON2 = 0;
    OC1CON1bits.OCTSEL = 0b111;
    OC1CON1bits.OCM = 7;
    OC1R = PWM_Period / 2; 
    OC1RS = PWM_Period;
    OC1CON2bits.OCINV = 1; 
    OC1CON2bits.SYNCSEL = 0x1F; 
     _RP41R = 0b010000; // OC1 Output tied to RP41/RB9 (1,2EN Pin) (pg 180)
   
     
} 

void config_T1 (void) 
{
    
    _T1IF   = 1;
    _T1IP   = 1; 
    _T1IE   = 1; 
    PR1     = 62499;
    T1CONbits.TCKPS = 0b11;
    T1CONbits.TON  = 1;
    
}

void __attribute__((__interrupt__,no_auto_psv)) _T1Interrupt (void)
{
    
    if (tempf && FlagCount == 1)
    {
        FlagCount++;  
    }
    if (tempf && FlagCount == FlagCount+1)
    {
        UP = !UP;
        FlagCount++;
    }
    if (!tempf)
    {
        FlagCount = 1;
    }
    
    TMR1    = 0;   
    _T1IF   = 0;

}

int main(void)
{
    char S[80];
    char Z[80];
    double d_c;
    OSC_Config(); 
    config_T1(); 
    config_T2(); 
    config_T3(); 
    config_IO(); 
    config_ADC(); 
    LCD_init();
    config_PWM();
    
    
    while (1)
    {
        //***Temperature Sensor and LCD***//
        
        config_PWM();
                
        u16_adcVal = run_ADC(0);    
        f_adcVal = u16_adcVal/1024.0 * VREF; // Vout
        tempc = (f_adcVal*1000-424)/6.25;
        tempf = (tempc * 1.8) + 32;
        sprintf(S,"%4.0f\xDF""C"" %4.0f\xDF""F",(double) tempc, (double) tempf);
        
        if(tempf >75 && tempf <85)
        {
            sprintf(Z, "Duty Cycle:50 Percent");
        }
        if(tempf >=85 && tempf <100)
        {
            d_c = (1/(2-((tempf - 85)*0.0667)))*100;
            sprintf(Z, "Duty Cycle:%2.0f Percent", (double)d_c);
        }
        if(tempf <=75 && tempf >65)
        {
            d_c = (1/(2-((tempf*(-1)) + 75)*0.0667))*100;
            sprintf(Z, "Duty Cycle:%2.0f Percent", (double)d_c);
            
        }
        if(tempf <=65 || tempf >=100)
        {
            sprintf(Z, "Duty Cycle:100Percent");
        }
        LCD_command(0x84);
        LCD_sendstring(S);
        LCD_command(0xC1);
        LCD_sendstring(Z);
        
        
        
        //***Motor Control***//
        
        if(tempf >=85 && tempf < 100)
        {
            config_PWM();
            OC1R = (PWM_Period/(2-((tempf - 85)*0.0667))); //Speed control
            One_A = 1;
            Two_A = 0;
            Run_T3(1);  
        }
        
        if(tempf <= 75 && tempf > 60)
        {
            OC1R = (PWM_Period/(2-((tempf*(-1)) + 75)*0.0667)); //Speed control
            One_A = 0;
            Two_A = 1;
            Run_T3(1);
        }
        
        if(tempf >= 100)
        {
            OC1R = PWM_Period*2; //MAXIMUM OVERDRIVE
            One_A = 1;
            Two_A = 0;
            Run_T3(1);
        }
        
        if(tempf <= 60)
        {
            OC1R = PWM_Period*2; //MAXIMUM OVERDRIVE
            One_A = 0;
            Two_A = 1;
            Run_T3(1);
        }
        
        if(tempf >75 && tempf <85)
        {
            OC1R = PWM_Period/2;
            One_A = 0;
            Two_A = 0;
            Run_T3(1);
            
        }
        
        Run_T3(2);
        
    }
}
